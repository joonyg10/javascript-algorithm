# 문제번호 링크

#### [1. 문자열 압축](#문자열-압축)

#### [2. 오픈 채팅방](#오픈-채팅방)

#### [3. 타겟 넘버]()

#### [4. 인형뽑기](#인형뽑기)

#### [5. 124 나라](#124나라)

#### [6. 기능 개발](#기능개발)

#### [7. N으로 표현](#n으로-표현)

#### [9. 가장 먼 노드](#가장-먼-노드)

#### [10. 짝지어 제거 하기](#짝지어-제거하기)

#### [11. 행렬 테두리 회전하기](#행렬-테두리-회전하기)

#### [12. 메뉴 리뉴얼]

<br />
<br />

# 문자열 압축

[문제]: 연속해서 나온 같은 문자을 줄인다 (aa -> 2a). 이렇게 압축하는 경우 가장 짧게 압축되는 것?

1. 정규표현식을 이용 /.{1,n}/g
   - 정규표현식의 경우 공백에 따라 의미 달라지니 주의할 것!!
   - 위의 정규표현식을 이용하여 갯수 n개 만큼 스트링을 자른 배열을 얻을 수 있다.
2. (1)을 통해 얻은 배열에 대해 two pointer 시행

   - 다른 원소가 될 때 까지 뒤의 포인터를 ++
   - 같은 원소이면 (bp - fp)만큼을 해당 원소에 prefix로 붙이고 압축된 문자열 compressedStr에 더한다.
   - 주의할 점으로는 마지막원소를 포인트 하고 바로 위의 게산이 시행되기에 마지막 원소는 (bp - fp - 1) 이 된 것처럼 들어간다.
   - 이를 방지하기 위해 while문의 조건을 bp <= chunks.length로 처리할 수도 있으나 배열의 범위를 벗어나는 행위이기에 부적절!
   - 대신 반복하는 배열 chunks.push("")로 빈 문자열을 마지막 원소 다음으로 넣어주는 방식으로 해결

3. (2)로 부터 압축한 문자열의 length를 배열에 추가
4. Math.max(... 문자열 길이 배열)로 답을 반환

<br />
<br />

# 오픈 채팅방

[문제]: 닉네임 변경이 이전에 채팅방에 있던 이름내역도 변경되는데 모든 명령이 종료된 후, 채팅방 로그를 출력하시오

[변수 선언]

- orders: record[0] -> 입장, 떠남, 변경등의 내용을 담음
- idQueue: record[1] -> 채팅방에 입장 / 나간 순서를 id순으로 저장하는 queue
- idNameMap: record[2] -> id : 이름 으로 mapping 된 map 객체

1. record를 순회하면서 위의 변수들을 초기화, 이 때, CHANGE에 대해 id: 닉네임은 map.set()에 의해 자동으로 업데이트 됩니다.
2. order에 대해 Reduce함수를 적용하여 밑의 로직을 시행한 결과를 반환

1) order === CHANGE인 경우 1. 에서 자동으로 걸러 졌기에 바로 return
2) order가 ENTER, LEAVE 인지에 따라서만 메시지를 다르게하고 acc에 push

<br />
<br />

# 타겟 넘버

[문제] numbers 사이사이에 +, -를 넣어 target를 만들 수 있는 가짓수 구하기

[설계]

- backtracking으로 현재 idx에 해당 하는 숫자에 1, -1을 곱한 값을 다음 함수의 인자로 넘겨준다.
- idx가 numbers의 길이와 같은 경우 누적합이 target과 같은 경우에 한 해 answer의 카운터를 +1

[풀이]

1. backTrack함수를 선언 -> currIdx, acc(누적합) 의 인자를 받는다.
2. 다음 index = currIdx+1 에 해당하는 숫자에 1, -1을 더한 값을 acc에 추가한 뒤 , backtrack을 반복시킨다.
3. backTrack(-1, 0)로 백트래킹 시행 후 answer를 반환

<br />
<br />

## 인형뽑기

[문제] N \* N의 2차원 배열과 moves배열이 주어진다. moves의 각 원소에 해당하는 열에서 인형을 뽑아 stack에 담는데 2개 연속으로 같은 인형이 들어간 경우 2개의 인형은 사라진다. 이 때, 총 사라진 인형의 갯수를 구하시오

[refactor] 초기에는 배열에 대해 각 열을 새로 배열화 하여 map객체에 set(i, col[]) 하는 형식으로 진행하였으나, 일반 pointer로만 해결 가능하기에 Map객체 삭제

[변수 선언]

- stack: 뽑은 인형을 담아둘 배열
- prevStackPointer : stack에서 이전 위치를 가리킬 pointer로 매번 stack[length-1]로 계산하는 것이 비효율이라 선언
- pointer: number[]: moves와 같이 모든 열에 대해 맨 위에 있는 인형의 row를 저장

1. 모든 열에 대해 가장 위에 있는 인형의 row 위치를 pointer 배열에 update
2. moves의 순서에 따라 뽑은 인형을 담을 stack과 현재 stack에 대해 이전 위치를 가리키는 pointer 생성
3. moves를 순회하면서 해당 col에 해당하는 인형을 pointer[col]로 접근해 2)의 stack에 추가하고 pointer[col]는 다음 row를 가리키도록 ++ 해준다.
4. stack에 인형을 넣은 후, 이전을 가리키는 포인터와 비교한다.

1) 같은 경우 -> 이전과 현재 넣은 것을 삭제 -> stackPointer-- -> bombCnt += 2
2) 다른 경우 -> stackPointer++

<br />
<br />

# 기능개발

[문제] 먼저 배포되어야 하는 순서대로 작업의 진도, 속도가 저장된 배열이 주어진다. 앞의 작업이 종료되어야 배포가 가능하다고 할 때, 배포마다 몇개의 기능이 배포되는지를 반환하시오

[조건] 배열의 길이는 100이하이며, 진도, 속도 또한 100 이하의 자연수

[풀이]

1. (100 - 진도) / 속도를 하면 해당 기능별로 남은 작업일수를 얻을 수 있다.

- 이 때, Math.ceil를 통해 올림된 값을 구하도록 한다.

2. 1를 통해 leftDays라는 배열을 얻은 뒤 2개의 포인터를 선언한다. (two pointer활용)

3. <span style="color:lightpink">앞의 작업 남은 일수 >= 뒤의 작업 남은 일수 </span>의 경우 뒤의 작업은 앞의 것이 끝날때 까지 기다려야 하므로 뒤의 포인터를 다음 것으로 옮긴다.

4. <span style="color:lightpink">앞의 작업 남은 일수 < 뒤의 작업 남은 일수 </span>가 된 경우 앞의 기능이 완료 되었으므로 <span style="color:pink">_bp - fp_</span> 차이 만큼의 기능이 한번에 배포 된다.

   - answer.push(bp - fp)로 저장

5. fp, bp가 N보다 작을 때까지 4를 반복한 뒤 answer를 반환한다.

<br />
<br />

# 124나라

[문제] 모든 숫자는 1,2,4로 나타낼 수 있는데, 임의의 숫자 N이 주어졌을때, 124로 변환된 숫자를 구하시오

[조건] N <= 500,000,000

[규칙]

- 3개의 숫자로만 나타낸다는 점에서 3진수로 나타내는 것과 매우 유사하다
- 단, 모든 자리에 0이 있으면 안됨!

- 모든 자리가 1인 자리의 숫자는 3의 제곱수들로 이루어진 등비수열의 합의 범위와 연관이 있다.
- 예를 들어, 45의 경우 3^3까지 이루어진 수열 {1, 3, 9, 27}의 합 40 보다 크기에 3의 3 제곱수 까지의 수열로 만들 수 있다.
- 각 수열에 사용된 숫자들의 갯수를 배열로 표시하여 124로만 나타낼 수 있다.

_1. 주어진 수 N과 가장 가까운 3의 제곱수를 구한다. 공식은 등비수열의 합 공식에서 얻어 왔으며, log(2\*N+1) / log(3)으로 구할 수 있다._

_2. 1에서 구한 3의 제곱수에 대해 지수값을 구하여 배열을 만든다._

- 45의 경우 3\*\*3까지의 수들로 만들 수 있기에 [1, 1, 1, 1] 의 길이가 4인 배열을 만든다. 이 때, 각 자리는 1, 3, 9, 27의 값을 내포한다.

_3. N에 대해 배열의 합 (여기서는 내포된 값들의 합이므로 등비수열의 합을 구한다.)을 구하는 함수를 선언_

_4. N - 3)에서 구한 함수의 값 에 대해 1)의 함수를 실행한다._

- 45의 경우 배열의 합 40을 뺀 값인 5에 대해 1)을 시행하고, 2의 값을 구할 수 있다.

_5. 4에서 얻은 값 까지 배열의 맨 앞에서 부터 +1을 해준다._

- 45의 4) 시행값은 2이므로 i =0, 1에 대해 배열의 값을 더해준다.
- 결론으로 [2, 2, 1, 1]을 얻고 , 이떄 배열의 합은 44가 된다.

_6. 4)에 의해 N - 3)의 결과가 0이 될때까지 4, 5를 반복한다._

- 45에 대해서는 [3,2,1,1]을 얻는다.

_7. 다시 맨앞에서 부터 iterate하는데 아래의 규칙을 적용시킨다._
(1) 현재 요소 값이 3 이면 4로 변경해 준다.
(2) 현재 요소 값이 3보다 클 경우 현재 값 3개가 다음 요소의 1개로 변환이 가능하다.
다음 요소 += Math.Ceil(현재요소 / 3) - 1;
현재 요소 = 3으로 나눈 나머지

_8. reverse시켜주고 join 메소드를 활용해 하나의 스트링을 반환해준다._

<br />
<br />

# N으로 표현

[문제]: N, number가 주어지는 경우 number를 N으로만 표기할 수 있을 때, 사용된 N의 갯수를 구하여라
<span style="color:lightgray">(단, N의 갯수가 8이 넘어가는 경우 -1을 반환토록 한다.)</span>

[설계]

- N의 길이로 이루어진 배열을 선언하는데 dp[i] = i개의 N으로 만들 수 있는 숫자를 저장
- dp[i]에 넣을 숫자는
  <span style="color:lightpink">N으로만 만들 수 있는 수 + dp[i-1]에 저장된 값들에 N을 사칙연산한 결과</span>를 dp[i]에 넣는다. 이 때, dp[i]에 저장하는 건 Object로 넣어 hash가 빠르도록 한다.

[풀이]

1. N개의 숫자로만 만들 수 있는 숫자들을 저장하는 배열을 선언
   - i = 1은 2N, 1, 0, N\*\*2를 넣어 초기화까지 같이 해준다.
2. for문으로 8번 반복하며 dp[i-1]의 모든 값에 대해 N에 대한 사칙연산된 결과를 dp[i]로 추가한다.
   - 8번 이상 시행하면 -1을 반환하면 되니 for문은 8만 반복한다.
   - dp[i]에 추가는 hash로 의한 O(1)이 되기 위해, Map 테이블로 추가토록 한다.
3. 2.의 for문 <span style="color:lightgray">_(사칙연산이 완료)_</span>이 완료된 후, 현재 i에 대해 테이블에 number가 있다면 i를 반환하면 끝!

<br />
<br />

# 가장 먼 노드

<span style='color:skyblue'>**[문제]**</span> 1번 노드에서 가장 먼 노드의 갯수를 구하시오

<span style='color:skyblue'>**[조건]**</span> N <= 20,000, 간선 갯수 <= 50,000

<span style='color:skyblue'>**[설계]**</span>

- BFS를 진행하며, visited[curr] = visited[prev] + 1를 시행
- BFS종료하고, Visited에서 가장 큰 수 구하고, 갯수 구하는 filter돌리는 것은 비효율이라 판단
- 현재 노드 까지의 최단거리를 키로 하는 Map 객체를 생성!
- value로는 해당 최단 거리를 가지는 노드의 갯수를 저장한다.

- BFS를 위한 Queue가 필요. 단, shift()의 경우 O(N)의 시간복잡도를 가지기에 배열에서 실제로 빼는 것 대신에 pointer 2개를 두어 맨 앞과 끝을 표시토록하는 클래스를 선언

<span style='color:skyblue'>**[풀이]**</span>

1. Queue 클래스 생성
   - enqueue, dequeue, size, empty 4개의 method 선언
2. 변수 선언

   - graph: {현재 노드 : 인접한 노드들의 리스트}
   - visited: BFS를 위한 리스트로 idx자체가 노드를 대변하며 그 값은 노드 1번에서의 최단거리가 저장된다.
   - queue : Queue 객체
   - answer: {최단거리: 해당 최단거리에 해당하는 노드 갯수}

3) BFS를 시행

   (1) 조건은 queue가 empty가 아닐때 까지

   (2) 현재 노드 까지의 최단 거리를 edgeCnt변수에 저장한뒤

   (3) answer에 최단 거리 갯수를 업데이트 한다.

   (4) 현재 노드에 대해 인접 노드들의 리스트를 graph에서 얻어와 visited[adjNode] = visited[curr] + 1을 시행해준 뒤 queue에 enqueue

   - 이 때, visited[adjNode], 즉, 앞서 방문한 적이 있는 노드의 경우 continue로 건너뛴다.

<br />
4) answer는 Map객체 이므로 key: value쌍이 순서대로 들어간다. 즉, 가장 마지막으로 들어간 key값은 가장 멀리 떨어진 노드 까지의 거리가 되며 그 value가 해당 거리를 가지는 노드의 갯수이다.
   - [...Map].pop()으로 마지막 [key, value] 쌍을 가져온 뒤 value를 반환

<br />
<br />

# 짝지어 제거하기

<span style="color:skyblue">**[문제]**</span>

문자가 주어질때, 연속된 2개가 같은 경우 제거할 수 있다.
주어진 문자에 대해 모든 문자가 위 규칙에 의해 사라질 수 있는지에 대한 여부를 판별하시오

<span style="color:skyblue">**[조건]**</span>

<span style="color:skyblue">**[풀이]**</span>

1. stack을 만들고 문자열의 맨 앞부터 스택 top과 비교한다.

   - 만약 같다면 -> stack.pop() <br />
     &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 다르면 -> stack.push()

2. 문자열을 모두 iterate하고 empty라면 모든 문자에 대해 조건에 따라 사라진 것이므로 1을 , !empty 라면 0을 반환한다.

<br />
<br />

# 행렬 테두리 회전하기

<span style="color:skyblue">**[문제]**</span>

<span style="color:skyblue">**[조건]**</span>

<span style="color:skyblue">**[풀이]**</span>

- 회전의 시적점에서 부터 [sx, sy] 1바퀴를 DFS로 진행하면 된다. (종료는 다시 [sx, sy]로 돌아온 경우)
- 이 때, DFS를 하면서 진행했던 지점의 모든 숫자를 heap에 넣어주어 각 회전마다의 최솟값을 찾는다.

1. 시작, 종료 지점의 좌표를 구조분해 할당을 통해 구한다. [sx, sy], [ex, ey]
2. 시작 좌표에 해당하는 행렬에 Token을 넣어 초기화 시켜준다. _(이 토큰이 추후 DFS의 종료조건이 된다.)_
3. 해당 위치에서 부터 시작해 DFS를 시행한다.

   - 현재 좌표의 값과 이전 좌표의 값을 swap하며 현재 좌표를 스택에 추가하는 방식
   - 현재 좌표와 [sx, sy], [ex, ey]를 비교하여 방향을 결정해 준다.
   - 마찬가지로, 현재값은 모두 heap에 넣어 주어 최솟값을 구하도록 한다.

4. DFS 종료후 , heap에서 최솟값ㅇ르 구해, answer에 추가한다.
5. 모든 쿼리에 대해 1 ~ 4를 시행하고 answer를 반환해 준다.

<br />
<br />

# 메뉴 리뉴얼

<span style="color:skyblue">**[문제]**</span>

- 2번이상 사람들이 가장 많이 시킨 요리들만을 뽑아 코스요리를 만드려고 한다.
- 각 길이의 코스요리 set중, 가장 많이 시킨 요리만을 코스요리로 추가한다고 할 때, 가능한 코스요리의 갯수를 구하시오
- (단, 코스요리는 오름차순으로 정렬하여 반환)

<span style="color:skyblue">**[조건]**</span>

- 2 <= order.length <= 20
- 1 <= course.length <= 10

<span style="color:skyblue">**[풀이]**</span>

1. 각 order에 대해 가능한 조합을 저장할 수 있는 Map객체를 선언한다.
2. getCombination 함수를 recursive하게 시행하여, (1)의 Map객체를 초기화 시킨다.
   (1) 각 order에 대해 포인터를 맨 앞에서 부터 올린다.
   (2) acc += order[i]로 누적된 메뉴의 조합을 재귀함수의 다음 인자로 전달한다.
   (3) 누적된 조합의 길이가 2이상인 경우에 대해서만, Map객체에 추가한다.

3. course에 대해 map을 시행하여, 각 길이에 해당하는 코스요리 중 가장 많이 주문된 것을 answer배열에 추가한다.
   (1) 현재 course의 값 c을 정의
   (2) Map객체를 filter하여, order(key).length === c이고, orderCnt(value) >= 2인 것을 조건으로 준다.
   (3) (2)에서 value에 대해 가장 큰 값을 구해야 하기에 Math.max을 써도 되지만, 그 경우 (2)배열을 1번더 순회하여야 한다.
   그렇기에, (2)자체를 sort (by value)하여 value에 대해 내림차순으로 정렬한다.

(4) (3)의 sort된 배열의 [0]값이 가장 많이 주문된 메뉴와 그 횟수이다. 다시 배열을 순회하면서 value가 이 값과 같은 경우 answer에 추가하고, 아니라면 break하여 빠져 나온다.
(모든 배열을 순회할 필요 없으며, 값이 달라지는 순간 바로 순회를 중단하기에 단순 Math.max와 1번더 순회하는 것 보다는 빠르다 생각한다.)

4. 3. 에서 구한 answer.sort()로 메뉴를 오름차순으로 정렬하여 반환한다.
