# 문제번호 링크

#### [문자열 압축](#문자열-압축)

#### [오픈 채팅방](#오픈-채팅방)

#### [인형뽑기](#인형뽑기)

<br />
<br />

## 문자열 압축

[문제]: 연속해서 나온 같은 문자을 줄인다 (aa -> 2a). 이렇게 압축하는 경우 가장 짧게 압축되는 것?

1. 정규표현식을 이용 /.{1,n}/g
   - 정규표현식의 경우 공백에 따라 의미 달라지니 주의할 것!!
   - 위의 정규표현식을 이용하여 갯수 n개 만큼 스트링을 자른 배열을 얻을 수 있다.
2. (1)을 통해 얻은 배열에 대해 two pointer 시행

   - 다른 원소가 될 때 까지 뒤의 포인터를 ++
   - 같은 원소이면 (bp - fp)만큼을 해당 원소에 prefix로 붙이고 압축된 문자열 compressedStr에 더한다.
   - 주의할 점으로는 마지막원소를 포인트 하고 바로 위의 게산이 시행되기에 마지막 원소는 (bp - fp - 1) 이 된 것처럼 들어간다.
   - 이를 방지하기 위해 while문의 조건을 bp <= chunks.length로 처리할 수도 있으나 배열의 범위를 벗어나는 행위이기에 부적절!
   - 대신 반복하는 배열 chunks.push("")로 빈 문자열을 마지막 원소 다음으로 넣어주는 방식으로 해결

3. (2)로 부터 압축한 문자열의 length를 배열에 추가
4. Math.max(... 문자열 길이 배열)로 답을 반환

<br />
<br />

## 오픈 채팅방

[문제]: 닉네임 변경이 이전에 채팅방에 있던 이름내역도 변경되는데 모든 명령이 종료된 후, 채팅방 로그를 출력하시오

[변수 선언]

- orders: record[0] -> 입장, 떠남, 변경등의 내용을 담음
- idQueue: record[1] -> 채팅방에 입장 / 나간 순서를 id순으로 저장하는 queue
- idNameMap: record[2] -> id : 이름 으로 mapping 된 map 객체

1. record를 순회하면서 위의 변수들을 초기화, 이 때, CHANGE에 대해 id: 닉네임은 map.set()에 의해 자동으로 업데이트 됩니다.
2. order에 대해 Reduce함수를 적용하여 밑의 로직을 시행한 결과를 반환

1) order === CHANGE인 경우 1. 에서 자동으로 걸러 졌기에 바로 return
2) order가 ENTER, LEAVE 인지에 따라서만 메시지를 다르게하고 acc에 push

<br />
<br />

## 인형뽑기

[문제] N \* N의 2차원 배열과 moves배열이 주어진다. moves의 각 원소에 해당하는 열에서 인형을 뽑아 stack에 담는데 2개 연속으로 같은 인형이 들어간 경우 2개의 인형은 사라진다. 이 때, 총 사라진 인형의 갯수를 구하시오

[refactor] 초기에는 배열에 대해 각 열을 새로 배열화 하여 map객체에 set(i, col[]) 하는 형식으로 진행하였으나, 일반 pointer로만 해결 가능하기에 Map객체 삭제

[변수 선언]

- stack: 뽑은 인형을 담아둘 배열
- prevStackPointer : stack에서 이전 위치를 가리킬 pointer로 매번 stack[length-1]로 계산하는 것이 비효율이라 선언
- pointer: number[]: moves와 같이 모든 열에 대해 맨 위에 있는 인형의 row를 저장

1. 모든 열에 대해 가장 위에 있는 인형의 row 위치를 pointer 배열에 update
2. moves의 순서에 따라 뽑은 인형을 담을 stack과 현재 stack에 대해 이전 위치를 가리키는 pointer 생성
3. moves를 순회하면서 해당 col에 해당하는 인형을 pointer[col]로 접근해 2)의 stack에 추가하고 pointer[col]는 다음 row를 가리키도록 ++ 해준다.
4. stack에 인형을 넣은 후, 이전을 가리키는 포인터와 비교한다.

1) 같은 경우 -> 이전과 현재 넣은 것을 삭제 -> stackPointer-- -> bombCnt += 2
2) 다른 경우 -> stackPointer++
